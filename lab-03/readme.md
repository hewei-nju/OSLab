# Lab-03

## 1. 前缀知识

### 1. 特权级概述

IA32 的分段机制中，特权级分为4个级别，高到低分别位0，1，2，3；

较为核心的代码和数据，将被放在特权级别较高的层级中；处理器将使用这样的机制来避免低特权级的任务在不被允许的情况下访问位于高特权级的段；

#### 1. CPL、DPL、RPL

处理器通过识别上面这三种特权级进行检验；

1. CPL：Current Privilege Level，当前执行的程序或任务的特权级；
2. DPL：Descriptor Privilege Level，表示段或门的特权级；当当前代码段试图访问一个段或者门时，DPL 会和 CPL 以及段或门选择子的 RPL 进行比较，根据段或门类型的不同，DPL 将会被区别对待；
    * 数据段：DPL 规定了可以访问此段的最低特权级；
    * 非一致代码段(不使用调用门)：DPL 规定访问此段的特权级；
    * 调用门：DPL 规定了当前执行的程序或任务可以访问此调用门的最低特权级；
    * 一致代码段和通过调用门访问的非一致代码段：DPL 规定了访问此段的最高特权级；
    * TSS：DPL 规定了可以访问此 TSS 的最低特权级；
3. RPL：Requested Privilege Level，提出访问请求的段的特权；

### 2. 门

#### 1. 门描述符

```
[byte7][byte6][byte5][byte4][byte3][byte2][byte1][byte0]
| 偏移        | 属性         | 选择子       | 偏移        |
                     |
[7][6][5][4][3][2][1][0] [7][6][5][4][3][2][1][0]
|P|| DPL||S|| TYPE     | |0||0||0|| Para Count  |
```

* 主要定义了目标代码段的选择子、入口地址的偏移量等等；
* 一个门描述了由一个选择子和一个偏移所指定的线性地址，程序基于这个地址进行转移；
* 门的分类：
    1. Call gates；
    2. Interrupt gates；
    3. Trap gates；
    4. Task gates；

#### 2. 调用门特权检验规则

代码 A 想要转移到代码 B，运用一个调用门 G。

|                    | call                                             | jmp                                                |
| ------------------ | ------------------------------------------------ | -------------------------------------------------- |
| 目标是一致代码段   | CPL <= DPL_G, <br>RPL <= DPL_G, <br>DPL_B <= CPL | CPL <= DPL_G, <br/>RPL <= DPL_G, <br/>DPL_B <= CPL |
| 目标是非一致代码段 | CPL <= DPL_G, <br>RPL <= DPL_G, <br>DPL_B <= CPL | CPL <= DPL_G, <br/>RPL <= DPL_G, <br/>DPL_B == CPL |

* 特权级变化的时候，堆栈也要变化，这样就避免了跳转到高特权级的过程中由于栈空间不足而崩溃；

### 3. 页式存储

#### 1. 基本概念

**页**：就是一块内存，在 80386 中，页的大小是固定的 4096 字节(4KB)；

**逻辑地址、线性地址、物理地址**：

未打开分页机制时，线性地址等于物理地址，逻辑地址通过分段机制直接转换成物理地址；

打开分页时，分段机制将逻辑地址转换成线性地址，线性地址再通过分页机制转换成物理地址；

```
逻辑地址 ---- [分段机制] ----> 线性地址 ---- [分页机制] ----> 物理地址
```

**为什么分页**：希望实现虚拟存储器；

## 2. 实现过程

根据系统代码实验要求，使用书本给出的[源代码](https://github.com/whirlys/ORANGE_OS/tree/master/chapter7/n/);

### 1. 光盘下载的源代码跑不了

**报错**：

```
00000000000p >>PANIC<< dlopen failed for module 'x': file not found
```

**solve**：

```
sudo apt-get install bochs-x
```

> https://sourceforge.net/p/bochs/discussion/39592/thread/caf74ad8/

### 2. 源代码跑起来的过程

#### 1. Makefile 解析以及相关文件总览

整个 Makefile 是从上往下是上面的目标依赖下面的内容；

* `@$` ：表示目标；
* `@<`：表示第一个依赖文件；
* `@^`：表示所有依赖文件；
* `.PHONY`：表示这是伪目标；

从整个 Makefile 的结构很容易得知：

* ./include、./kernel、./lib 这个三个目录夹下德内容都是为了生成 ./kernel.bin 即内核；

* ./boot 目录下的内容就是启动和加载的内容；

    * ./boot/boot.asm 是为了生成 ./boot/boot.bin 启动程序，也就是引导扇区，512B；
    * ./boot/loader.asm 是为了生成 ./boot/loader.bin 加载程序，用来加载内核；
    * ./boot/include 目录下的内容就是抽象出的一些设置/配置文件：
        * ./boot/include/fat12hdr.inc 是 FAT12 文件中**引导扇区**，也就是第一个扇区中的内容，主要是规定文件的相关参数；
        * ./boot/include/load.inc 定义了各种地址，包括 ./kernel.bin 被加载到的地址等等；
        * ./boot/include/pm.inc 定义了进入保护模式的相关数据；

* 回到 Makefile，重点关注 buildimg：

    1. 它先将 ./boot/boot.bin 写入 a.img 这个软盘，大小为1个扇区；

    2. 然后挂载的目的是为了将 ./boot/loader.bin 和 ./kernel.bin 写入软盘；

    3. 得到的软盘结构：

        ```
        [引导扇区，boot.bin]
        [loader.bin       ]
        [kernel.bin       ]
        [other            ]
        ```

* 我新添加一个伪目标，目的是为了直接在 bochs 虚拟机中将该操作系统跑起来：

    ```
    run : buildimg
    	bochs -f bochsrc
    ```

* 通过 bochs 虚拟机运行在 a.img 软盘中的操作系统时，现在引导扇区中找 loader.bin，然后由 loader.bin 来加载内核。

#### 2. 内核中函数的调用关系

```
./boot/boot.asm {LABEL_START} ---> ./boot/loader.asm {LABEL_START} ---> ./boot/loader.asm {LABEL_PM_START} ---> ./kernel/kernel.asm {_start} ---> ./kernel/start.c {cstart} ---> ./kernel/kernel.asm {_start} ---> ./kernel/kernel.asm {csinit} -> ./kernel/main.c {kernel_main}
```

> PS：这个过程中，我把代码的逻辑都给理了一遍，大多了，就不一一加上了！其实对于 Lab 而言，直接看书第7章就可以完成；

#### 3. 重要思想

**1. 首先是对于 终端、控制台、TTY、CONSOLE、Keyboard 的理解**：

[终端、Shell、tty 和控制台（console）有什么区别？](https://www.zhihu.com/question/21711307)

**2. 实现 backspace**：

* 增加对**换行符、Tab 键**的特殊处理，即增加记录产生了多少个空格，对其进行统一删除；
* 增加对普通字符的记录，便于删除；

**3. 实现搜索模式**：

* 增加关键字的记录，以及进入搜索模式的标识；

**4. 屏幕刷新**：

* 在 TTY 任务中定时刷新；

**5. CTRL + Z 撤销操作**：

* 增加对屏幕上所有有效操作的记录；
* 对 CTRL 键进行处理；

## 3. Features

- [x] 白色显示键盘输入的字符，可以输入并显示 a-zA-Z0-9 字符；
- [x] 大小写切换、Shift 组合键、大写锁定；大写锁定后再用Shift 组合键会输入小写字母；
- [x] 支持回车键换行；
- [x] 支持退格键删除内容；
- [x] 支持空格键和 Tab 键(4 个空格，可以被同意删除)；
- [x] 光标可以跟随字符的位置变化；
- [x] 每隔 20s 清空屏幕；输入的字符重新从屏幕左上角开始显示；
- [x] 输入字符数没有限制；
- [x] 支持屏幕滚动翻页；
- [x] 支持方向键移动光标； 
- [x] 按 Esc 键进入查找模式，查找模式中不会清空屏幕；
- [x] 查找模式输入关键字，被输入的关键字以红色显示；
- [x] 按回车后，所有匹配的文本(区分大小写)以红色显示，并屏蔽除 Esc 以外的任何输入；
- [x] 再按 Esc 键，之前输入的关键字被自动删除，所有文本恢复白色，光标回到正常位置；
- [x] 按下 control + z 组合键可以撤回操作，直到初始状态； 

> 1. 针对 CTRL + Z 的组合键：我实现的想法是可以回撤当前未刷新屏幕的所有操作；因为刷新屏幕了，之前的内容没太多意义了，并且会导致占用大量内存。
> 2. CTRL 键为左键；
> 3. 刷新的时间是每隔 20s 刷新一次，如果处于搜索模式，则不刷新，所以视频中存在过了 1 分多钟才刷新。

## 4. 实验结果

```html
<video id="video" controls="" preload="none" poster="fig/fig/example.jpg">
      <source id="mp4" src="video/oslab3.mp4" type="video/mp4">
</videos>
```

## 5. CheckLists

### 1. 解释中断向量

对应每个中断源设置一个向量，这些向量顺序存在主存储器的特定存储区。向量的内容是相应中断服务程序的起始地址和处理机状态字。在响应中断时，由中断系统硬件提供向量地址，处理机根据该地址取得向量，并转入响应的中断服务程序；

### 2. 解释中断类型码

对每个中断服务程序进行编号，这个编号就代表一个中断服务程序，就是中断类型码。中断类型码是计算机用来查找中断向量用的。

中断指令的格式`int n`，其中 n 被称为中断类型码。

### 3. 解释中断向量表

* 中断向量表是指中断服务程序入口的地址的偏移量与段基址，一个中断i向量占据4字节空间。中断向量表是8086系统内存中最低端 1K 字节的空间，它的作用就是按照中断类型号从小到大的顺序存储对应的中断向量，总共存储256个中断向量；
* 中断向量表在内存单元的最低处，地址空间未 00000H-003FFH(0-1024B)；
* 这个地址和中断类型码由一种对应关系：中断类型码*4就是这个中断向量的首地址；
* 每一个中断向量所包含的地址以低位2字节存储偏移量，高位2字节存储段地址；
* 按照实模式的寻址方式找到对应的中断处理入口；
    * 简而言之就是：不用去 GDT 中去查找其他的数据，这4字节就是中断服务入口的实际物理地址；
* 全部256个中断中，前32个为硬件系统所留，后224个可由用户自定义；

### 4. 实模式下中断程序地址如何得到?

根据中断类型码查找中断向量表，然后取得中断服务入口的基址和偏移量，拼接一下即为中断服务的入口地址；

### 5. 保护模式下中断程序地址如何得到?

* 保护模式下，为每一个中断和异常定义了一个中断描述符，来说明中断和异常服务程序的入口地址的属性；

* 使用中断描述符表取代实地址模式下的中断向量表；
* 中断描述符除了含有中断处理程序地址信息外，还包括许多属性和类型位；
* 每个中断描述符占用连续的8个字节，中断描述符分为3类：任务门、中断门、自陷门，CPU 对不同的门有不同的处理方式；

通过中断类型码查找中断描述符表，根据描述符结构查找中断子程序这个目标段的描述符；经过两次查表来获得中断服务子程序的入口；

1. 查中断描述符表以IDTR指定的中断描述符表的基地址为起始地址，用调用号N×8算出偏移量，即为N号中断门描述符的首地址，由此处取出中断门的8个字节；
2. 查全局或局部描述符表根据中断门中的选择子（段选择符）和偏移量得到中断处理程序入口；

### 6. 中断向量的地址如何得到?

4 * 中断向量码；

### 7. 实模式下如何根据中断向量的地址得到中断程序地址?

根据中断类型码查找中断向量表，然后取得中断服务入口的基址和偏移量，拼接一下即为中断服务的入口地址；

### 8. 解释中断描述符

```
[byte7][byte6][byte5][byte4][byte3][byte2][byte1][byte0]
|偏移量A31-A16||     ||     |  段选择符    || 偏移量A15-A0|         
                    ||
[7][6][5][4][3][2][1][0][7][6][5][4][3][2][1][0]
|P|| DPL||0|| TYPE  ||0  0  0||      保留       |
```

* 低地址的0和1两个字节是中断代码的偏移量A15-A0，高地址的6和7两个字节是中断代码的偏移量A31-A16；
* 2和3两个字节是段选择符，段选择符和偏移量用来形成中断服务子程序的入口地址；
* 4和5两个字节称为访问权限字节，它表示该中断描述符是否有效，服务程序的特权级和描述符的类型等信息；
    * P(Present)：表示中断描述符的有效性；
    * DPL（Description privilege level）；
    * TYPE：指示中断描述符的不同类型；

### 9. 保护模式下中断描述符表如何得到?

* 在80x86系列中为中断服务提供中断/陷阱描述符，这些描述符构成了中断描述符表(IDT)；
* 引入了一个48位的全地址寄存器 IDTR 存放 IDT 的内存地址，因此不再限于底部 1K 位置；
* IDTR 包含32位基地址和16位段限，基地址定义中断描述符表 IDT 在存储器中的起始点，段限定义中断描述符表所占的字节个数；

### 10. 保护模式下中断门如何得到?

通过中断类型码查找 IDT 获取中断门；

### 11. 保护模式下如何根据中断门得到中断处理程序地址?

通过中断门获取其中的段选择子和偏移量，查找全局或局部描述符表获取中断处理程序地址；

### 12. 中断的分类，举例不同类型的中断?

从中断源的角度分类：

* 由计算机硬件异常或故障引起的中断，也称为内部异常中断；
* 由程序中执行了中断指令引起的中断，也成为软中断；由程序员通过 INT 或 INT3 指令触发，通常当作 trap 处理；用于实现系统调用；
* 外部设备请求引起的中断，称为外部中断；

外部中断分类：

* 可屏蔽中断：禁止响应某个中断，保证在执行一些重要的程序中不响应中断，以避免造成迟缓而引起错误；
* 不可屏蔽中断：重新启动、电源故障、内存出错、总线出错等影响整个系统工作的中断是不能避免的。

其他视角：

* 中断：由 CPU 以外的事件引起的中断；
    * I/O 中断、时钟中断、控制台中断；
* 异常：来自 CPU 内部事件或程序执行中的事件引起的过程；
    * CPU 本身的故障、程序故障、请求系统服务的指令引起的中断；

### 13. 中断与异常的区别?

相同点：

* 都是程序执行过程中的强制性转移，转移到相应的处理程序；

不同点：

* 中断程序在程序执行时因为硬件而随机发生，通常用来处理处理器外部的事件，比如外围设备的请求；
* 软件通过执行`int n`指令也可以产生中断；
* 异常通常在处理器执行指令过程中检测到错误时发生，比如遇到零除情况；

### 14. 实模式和保护模式下的中断处理差别

* 实模式下，直接根据中断类型码获取中断服务程序的基地址和偏移量，拼接为中断程序的实际地址；
* 保护模式下，根据中断类型码查中断描述符表获取中断描述符，根据中断描述符获取中断服务程序的基地址和偏移量，拼接为中断程序的实际地址；
* 二者堆栈的变化也有很大区别，在树上

### 15. 如何识别键盘组合键（如 Shift + A）是否还有其他解决方案?

Orange’s 中，建⽴扫描码的解析数组记录⼀个键在组合及⾮组合状态下的实际值并设置缓冲区；声明了组合键中前者（Control，Shift 等）相应变量，若出现其 make code 或 break code，设置其标志位以便与其他⾮组合键组合在解析数组中找到相应实际值；

### 16. IDT 是什么，有什么作用?

IDT：Interrupt Description Table，中断描述符表；

IDT 的作用是将每个中断向量和一个门描述符对应起来；

### 17. IDT 中有几种描述符?

有3中描述符；

* 中断门描述符；
* 陷阱门描述符；
* 任务门描述符；

### 18. 异常的分类?

**Fault**：一种可被更正的异常，而且一旦被更正，程序可以不失连续性的继续；当一个 fault 发生时，处理器会把产生 fault 的指令之前的状态保存起来。异常处理程序的返回地址将会是产生 fault 的指令，而不是其后的那条指令；

**Trap**：一种发生在 trap 的指令执行之后立即被报告的异常，它也允许程序或任务不失连续性的继续执行。异常处理程序的返回地址将会是产生 trap 的指令之后的那条指令；

**Abort**：一种不总是报告精确异常发生位置的异常，它不允许程序或任务继续执行，而是用来报告严重错误的；

### 19. 用户态和内核态的特权级分别是多少?

用户态：3；内核态：0；

### 20. 中断向量表中，每个中断有几个字节?里面的结构是什么?

4个字节；结构如下：

```
[中断0的偏移]
[中断0的基址]
[中断0的偏移]
[中断0的偏移]
...
```

### 21. 中断异常共同点（至少两点），不同点（至少三点

共同点：

* 都是程序执行过程中的强制性转移，转移到相应的处理程序；
* 都是软件或硬件发生了某种情形而通知处理其的行为；

不同点：

* 中断是 CPU 所具备的功能。通常因为“硬件”而随机发生；
* 异常是软件运行过程中的一种开发过程中没有考虑到的程序错误；
* 中断是 CPU 暂停当前工作，有计划的去处理其他的事请。中断的发生一般是可以预知的，处理的过程也是事先制定好的；处理中断时程序是正常运行的；
* 异常是 CPU 遇到了无法响应的工作，而后进入一种分正常状态，异常的出现表明程序有缺陷；
* 中断是异步的，中断时来自处理器外部的 I/O 设备的信号的结果，它不是由指令流中某条指令执行引起的，从这个意义上讲，它是异步的，是来自指令流之外的；
* 异常是执行当前指令流中某条指令的结果，是来自指令流内部的，从这个意义上讲它们是同步的；
* 良性的如中断和trap，只是在正常的工作流之外执行额外的操作，然后继续干没干完的活。因此处理程序完了后返回到原指令流的下一条指令，继续执行；
* 恶性的如fault和abort，对于可修复fault，由于是在上一条指令执行过程中发生（是由正在执行的指令引发的）的，在修复fault之后，会重新执行该指令；至于不可修复fault或abort，则不会再返回；
* 中断是由于当前程序无关的中断信号触发的，CPU对中断的响应是被动的，且与CPU模式无关。既可以发生在用户态，又可以发生在核心态；
* 异常是由CPU控制单元产生的，大部分异常发生在用户态。
