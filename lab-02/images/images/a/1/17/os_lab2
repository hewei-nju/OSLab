#### 1. 一段可能的 FAT 表项解读
``` 00000200 f0 ff ff 00 f0 ff ff 0f 00 00 00 00 00 f0 ff 00 ``` * 前三个字符为固定值 
`f0 ff ff` 表示这是 FAT12 文件系统； FAT12 
表项有12位构成，即1.5个Byte，如何解读顺序就很重要： 
想象为一块从上往下由低地址到高地址的排列： ``` f0 ff ff 00 f0 ff ff 0f 00 00 00 00 00 f0 
ff 00  高 ``` 
默认为高地址的值的"阶"高于地址值的值，所以排除固定的三个字符后顺序表示是： * 
从低地址到高地址，000 fff fff 000 000 000 000 fff 00；
#### 2. 根目录区
| 偏移量 | 长度 | 描述 | ------ | ---- | 
| ---------------------------------------------------------- | 0 | 8 | 
| 文件名，文件的基本名称；未满8位填充空格 0x20 | 8 | 3 | 
| 文件扩展名，'.'后面的名称；未满8位填充空格 0x20 | 11 | 1 | 文件属性，0x10 -> 
| 目录，0x20 -> 普通文件，0x27 -> 隐藏文件 | 12 | 10 | 保留位 | 22 | 2 | 创建时间 | 24 | 
| 2 | 创建日期 | 26 | 2 | 首簇号 | 28 | 4 | 文件大小 |
由于 FAT 的前三个字节的值是固定的0xF0、0xFF、0xFF，用于表示者事一个应用在 1.44M 软盘上的 
FAT12 文件系统。 本来序号为0和1的 FAT 
表项应该对应于簇0和簇1，但由于这两个表现成了固定值，簇0和簇1就没有了存在的意义，因此数据区起始于簇2. 
0x4200对应于簇2的起始位置； FAT 项的值表示文件的下一个簇号； 当 FAT 
项的值大于或等于0xFF8时，表示当前簇已经是本文件的最后一个簇了； 
如果值为0xFF7则表示为一个坏簇；
## 3. 实现思路
因为一个 1.44M 大小的软盘总共 1474560 个字节，所以直接将软盘里所有的内容映射为一个一维的 
char 数组，然后通过 char 数据构建目录/文件树，其他操作就是对目录/文件树进行搜索。 
3个点： 1. 映射后，相关数据的位置如何计算？
    * 通过 FAT12 文件系统的结构，很容易得知映射数据位置的计算方式； 2. 
如何构建目录/文件树？
    * 
先将当前目录和当前目录下的文件/目录的局部树形结构构建，然后对当前目录下的所有子目录进行同样的操作，即递归即可。 
3. 如何搜索？
    * 就是搜索树形结构，深搜/广搜。 上面的思路的一个例子： ```
# 目录/文件树
A
|-----------------B ----------C |----------B2
+D.TXT | |-----B1
           +C1.TXT
 构建过程：
 *: 表示文件，不会对他进行递归构建目录/文件树;
 -: 表示已经弹出数据结构；
 1. 构建 A 和 B，C，D.TXT 之间的属性结构:
                 A B C D.TXT* 2. 依次对 B，C 递归构建目录树： 1）现对 B 
进行递归构建目录树
                   A
  B C D.TXT* B1 B2
                     A
    B C D.TXT* B1- B2
                     A
    B C D.TXT* B1- B2- 此时 B1，B2 这层为空，将其弹出，然后需要将B也弹出：
                     A
    B- C D.TXT* B1- B2- 2）对 C 进行递归构建目录树
                     A
    B- C D.TXT* B1- B2- C1.TXT*
                     A
    B- C- D.TXT* B1- B2- C1.TXT*
 
此时 B，C 这层为空，将其弹出，然后将 A 弹出，发现这个结构为空，终止！ ``` 
所以，很明显，就是一个 栈 + 队列 来深搜构建目录树，伪代码表示： ```c++ stack<queue<DIR>> 
stk; queue<DIR> que; que.push(ROOTDIR); stk.push(que); que.pop(); while (!stk.empty()) {
    que = stk.top();
    queue<DIR> nxtQue;
    
    while (!que.empty()) {
        DIR curDir = que.top();
        for (subDir: curDir.subDirs) {
            // 构建当前目录和它的子目录的树形结构
            if (ISDIR(subDir))
                nxtQue.push(subDir);
        }
        if (!nxtQue.empty()) {
            stk.push(nxtQue);
            goto while;
        } else {
            que.pop();
        }
    }
    
    if (!stk.empty()) {
     	stk.pop();
    }
    // 这一句是最重要的，hhh
    if (!stk.empty() && !stk.top().empty()) {
        stk.top().pop();
    }
}
```
